<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>page2 - 0.3 Data structures</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body>

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul class="collapse">
  <li><a href="#a-short-introduction-on-data-structures" id="toc-a-short-introduction-on-data-structures" class="nav-link active" data-scroll-target="#a-short-introduction-on-data-structures">A short introduction on Data structures</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">0.3 Data structures</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="a-short-introduction-on-data-structures" class="level1">
<h1>A short introduction on Data structures</h1>
<p>You don’t have to search for long to see different ways of organizing data in real life situations. Standing in line at the cafeteria, picking the winner in a March Madness bracket, writing down a shopping list, etc. All these examples allow us to use a certain resource in a manner that makes life somewhat easier. Computer Science, as a field, borrows a lot of these ideas in organizing data. The way that a programmer views and organizes the data that his/her program is using has bearing on the success/failure of multiple algorithms. Whereas the primitive types (int, float, double, long, char, byte, short, boolean) are adequate for simple programs, most programs you’ll be writing deal with large amounts of complicated and related data. In order to deal with such data, some structures have been used to represent this data and its relationships.</p>
<div style="page-break-after: always;"></div>
<p>Some data structures are based on how the programmer organizes the data i.e.&nbsp;how it is organized in memory. These structures are typically used as the basic building blocks of other structures. It is important to remember that with these structures, the implementation of the organization is what is important…more important than what kind of data is being organized, or when that data was encountered and/or organized.</p>
<ul>
<li><p>Arrays are the most basic. Recall from the Living with Cyber classes, that arrays are used to store similar data in contiguous memory locations. They are available in almost all programming languages and data is accessed using its relative position (i.e.&nbsp;index)</p></li>
<li><p>Linked Lists are also used to store elements in a sequence. However, the data is stored in nodes. Each node has one piece of data, as well as a link showing the location of the next node in the sequence. Think of a chain link.</p></li>
</ul>
<div style="page-break-after: always;"></div>
<p>These two basic structures are the building blocks of the other category of data structures i.e.&nbsp;those that are based on how the programmer views the data. Because these structures are based on how data is viewed (as opposed to how they are organized), sometimes these are called Abstract Data Types (remember “abstract” as a term refers to interpretation separate from concrete reality). These data structures are therefore independent of the implementation which is a concept that can be a little confusing the first time you hear about it.</p>
<ul>
<li><p>Stacks are data structures that arrange data based on when that data was encountered. In this case, the last in is also the first out (LIFO). Compare this to a stack of plates at Tech Table. This way of looking at a data structure has nothing o do with how it is implemented. It could be an array or linked list (behind the scenes). As long as the data structure works in a LIFO manner, then it can be called a stack.</p></li>
<li><p>Queues also arrange data based on when it was encountered but in a First In, First Out (FIFO) manner. Compare this to an orderly line to get your school identity card. Any piece of data removed from a queue is the piece of data that has been in the queue the longest.</p></li>
<li><p>List is just a linear arrangement of data. It could be an array or linked list (behind the scenes) but as long as it supports the arrangement of data in a linear manner, it can be referred to as a list. Sometimes lists can also be sorted.</p></li>
<li><p>Maps (a.k.a dictionaries, tables, associative arrays) are used to store key-value pairs. They allow the user quick access to a value when provided with the key. Compare it to your phone address book which hopefully provides you with a value (phone number, address, and message history) for every key (contact name) that you provide. Keys should be unique and each key should map to a single value.</p></li>
<li><p>Trees are non-linear data structures. Data arranged in a tree stores both the value and some kind of relationship between those values. The restriction in trees is that each node is capable of having multiple successor nodes, but only one parent node. The parent of all nodes (without a parent itself) is called the root. Think about a tournament bracket.</p></li>
<li><p>Graphs are also non-linear data structures but with less restrictions on the intra node relationships. Any node (typically called a vertex) can be connected (through an edge) to any other vertex. Sometimes even the edges have weights associated with them. Think road or airline routes.</p></li>
</ul>
<p><br></p>
<p><br></p>
<p>There are some basic definitions we need to get out of the way before we dive into more complicated stuff.</p>
<p><strong>Type</strong>: a collection of values. For example, a boolean type is collection of two values – true and false. A simple type (such as boolean or integer) will not have subparts, whereas an aggregate or composite type will contain several pieces of information.</p>
<p><strong>Data item</strong>: a data item is a member of the type i.e.&nbsp;a piece of information derived from a type.</p>
<p><strong>Data type</strong>: This is a combination of a type (the values) and the operations that can be applied to that type. For example, given the possible values of an integer (-231 – 231 -1), possible operations include addition, subtraction, division, etc.</p>
<p>There is a difference between the logical concept of a data type and its physical implementation (even if the line is blurred). Consider an array: Its logical concept is that of potentially homogeneous data items stored in a collection where each item is accessed using an index number. However, its physical implementation is a block of contiguous memory locations. The distinction between the two needs to be made because there are cases where arrays (particularly multi-dimensional arrays) have been designed with the same logical idea, but different physical implementation (i.e.&nbsp;the data items are not in contiguous memory locations) but that doesn’t make them any less of an array than a typical array. Another example is the list. Its logical concept is a collection of items, but its physical implementation could be either an array or a linked list. Both are lists, but they have very different physical implementations.</p>
<p><strong>Abstract data type</strong>: When the idea of a data type is realized as a software component i.e.&nbsp;the type and operations are realized in code. This is typically represented by an interface. It does NOT specify how the data type is implemented. In fact, such details are typically hidden from the user of the data type or any outside access.</p>
<p><strong>Data structure</strong>: The complete implementation of an ADT. It typically takes the form of a class where the operations of the ADT are captured by member functions of that class.</p>
<p>An integer as well as the operations that an integer can be put through make up the integer data type. The java int variable is a physical representation of the abstract integer. This variable, alongside the java int operations make up an ADT. But there is difference between the two (i.e.&nbsp;a difference between a java int ADT and the abstract integer). The java int ADT can only support values within a certain range and we know that real integers do not have that limitation. If this limitation is a deal breaker for you, then you will have to figure out a different ADT (with different implementations) to represent your integers. <br></p>
<p><br> <br></p>
<p><br> <br> <br> <br> Ref:<br></p>
<p>A Practical Introduction to Data Structures and Algorithm Analysis, Clifford A. Shaffer ; Object Oriented Data Structures using Java (4th Edition). Nell Dale, Daniel T. Joyce, Chip Weems.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>